<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nhận Diện Biểu Cảm Khuôn Mặt</title>
    <!-- Thêm Tailwind CSS qua CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-gray-100 font-sans">
    <div class="container mx-auto p-4">
      <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">
        Nhận Diện Biểu Cảm Khuôn Mặt
      </h1>

      <!-- Layout hai cột cho desktop, một cột cho mobile -->
      <div class="grid grid-cols-1 lg:grid-cols-12 gap-6">
        <!-- Cột bên trái - Tab và Webcam/Upload (8/12 cột trên desktop) -->
        <div class="lg:col-span-8 order-1">
          <!-- Tab Navigation -->
          <div class="flex mb-4 border-b">
            <button
              class="tab py-2 px-4 rounded-t-lg bg-gray-200 hover:bg-gray-300 mr-2 active"
              data-tab="upload"
            >
              Tải lên hình ảnh
            </button>
            <button
              class="tab py-2 px-4 rounded-t-lg bg-gray-200 hover:bg-gray-300 mr-2"
              data-tab="webcam"
            >
              Sử dụng Webcam
            </button>
            <button
              class="tab py-2 px-4 rounded-t-lg bg-gray-200 hover:bg-gray-300"
              data-tab="paste"
            >
              Dán ảnh
            </button>
          </div>

          <!-- Tab Content Wrapper -->
          <div class="bg-white p-4 rounded-lg shadow-md mb-6">
            <!-- Upload Tab Content -->
            <div class="tab-content active" id="upload-tab">
              <h2 class="text-xl font-semibold mb-4">Tải lên hình ảnh</h2>
              <div class="mb-4">
                <input
                  type="file"
                  id="imageUpload"
                  accept="image/*"
                  class="mb-3 block w-full"
                />
                <button
                  type="button"
                  id="submitBtn"
                  class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition"
                >
                  Phân tích
                </button>
              </div>
              <div id="uploadLoading" class="text-center py-3 hidden">
                Đang xử lý...
              </div>
              <div id="uploadError" class="text-red-500 mt-3 hidden"></div>
            </div>

            <!-- Webcam Tab Content -->
            <div class="tab-content hidden" id="webcam-tab">
              <h2 class="text-xl font-semibold mb-4">Sử dụng Webcam</h2>
              <div class="mb-4">
                <div class="flex flex-wrap gap-2">
                  <button
                    id="startWebcam"
                    class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition"
                  >
                    Bật Webcam
                  </button>
                  <button
                    id="stopWebcam"
                    class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition hidden"
                  >
                    Tắt Webcam
                  </button>
                  <button
                    id="captureBtn"
                    class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition hidden"
                  >
                    Chụp ảnh
                  </button>
                </div>
              </div>
              <div class="relative webcam-container">
                <video
                  id="video"
                  class="max-w-full h-auto mx-auto hidden border border-gray-300 rounded-lg"
                  autoplay
                ></video>
                <canvas
                  id="captureCanvas"
                  class="absolute top-0 left-0 pointer-events-none hidden"
                ></canvas>
              </div>
              <div id="webcamLoading" class="text-center py-3 hidden">
                Đang xử lý...
              </div>
              <div id="webcamError" class="text-red-500 mt-3 hidden"></div>
            </div>

            <!-- Paste Tab Content -->
            <div class="tab-content hidden" id="paste-tab">
              <h2 class="text-xl font-semibold mb-4">Dán ảnh</h2>
              <div class="mb-4">
                <p class="text-gray-600 mb-2">
                  Nhấn <strong>Ctrl+V</strong> hoặc nhấp chuột phải và chọn
                  "Dán" để dán ảnh từ clipboard.
                </p>
                <div
                  id="pasteArea"
                  class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center bg-gray-50 hover:bg-gray-100 transition"
                >
                  <p class="text-gray-500">Dán ảnh vào đây</p>
                  <img
                    id="pastedImagePreview"
                    class="max-w-full h-auto mx-auto mt-4 hidden"
                    alt="Pasted image preview"
                  />
                </div>
                <button
                  id="pasteSubmitBtn"
                  class="mt-4 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition hidden"
                >
                  Phân tích
                </button>
              </div>
              <div id="pasteLoading" class="text-center py-3 hidden">
                Đang xử lý...
              </div>
              <div id="pasteError" class="text-red-500 mt-3 hidden"></div>
            </div>
          </div>

          <!-- Phần kết quả (chỉ hiển thị trong cột trái) -->
          <div
            id="resultContainer"
            class="bg-white p-6 rounded-lg shadow-md mb-6 hidden"
          >
            <!-- Kết quả phân tích sẽ được hiển thị ở đây -->
          </div>
        </div>

        <!-- Cột bên phải - Lịch sử (4/12 cột trên desktop) -->
        <div class="lg:col-span-4 order-2">
          <!-- History Container -->
          <div
            id="historyContainer"
            class="bg-white p-4 rounded-lg shadow-md mb-6 lg:sticky lg:top-4"
          >
            <div class="flex justify-between items-center mb-4">
              <h2 class="text-xl font-semibold">Lịch sử phát hiện</h2>
              <button
                id="clearHistoryBtn"
                class="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 transition"
              >
                Xóa lịch sử
              </button>
            </div>
            <div
              id="historyGrid"
              class="divide-y divide-gray-200 overflow-y-auto max-h-[calc(100vh-150px)]"
            >
              <!-- Các phần tử sẽ được thêm vào đây bằng JavaScript -->
            </div>
          </div>
        </div>
      </div>
    </div>

    <style>
      /* Thêm CSS để đảm bảo sidebar có thể cuộn độc lập */
      @media (min-width: 1024px) {
        #historyContainer {
          max-height: calc(100vh - 120px);
          height: auto;
          overflow-y: auto;
        }

        #historyGrid {
          height: auto;
          max-height: calc(100vh - 200px); /* Điều chỉnh để tránh xung đột */
        }
      }

      /* Thêm thanh cuộn đẹp hơn */
      #historyGrid::-webkit-scrollbar {
        width: 6px;
      }

      #historyGrid::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
      }

      #historyGrid::-webkit-scrollbar-thumb {
        background: #ccc;
        border-radius: 10px;
      }

      #historyGrid::-webkit-scrollbar-thumb:hover {
        background: #999;
      }
    </style>

    <script>
      // Global Variables
      let detectionHistory = []; // History data
      let currentCapturedImage = null; // Stores the base64 of the current image
      let pastedImageBase64 = null; // Stores the base64 of the pasted image
      let stream = null; // Webcam stream
      let isCaptureCooldown = false; // Cooldown for capturing images
      const CAPTURE_COOLDOWN = 0; // Cooldown time (set to 0 for no delay)
      let captureTimer = null; // Timer for cooldown
      let lastCapturedHash = null; // Hash of the last captured image to avoid duplicates

      // IndexedDB variables
      let db = null;
      const DB_NAME = "FaceDetectionHistory";
      const DB_VERSION = 1;
      const STORE_NAME = "detectionHistory";

      // Utility Functions
      function showError(message, errorElementId) {
        const errorElement = document.getElementById(errorElementId);
        if (errorElement) {
          errorElement.textContent = message;
          errorElement.classList.remove("hidden");
        }
      }

      function showNotification(message, type = "info") {
        let notificationContainer = document.getElementById(
          "notificationContainer"
        );
        if (!notificationContainer) {
          notificationContainer = document.createElement("div");
          notificationContainer.id = "notificationContainer";
          notificationContainer.className = "fixed bottom-4 right-4 z-50";
          document.body.appendChild(notificationContainer);
        }

        const notification = document.createElement("div");
        notification.className = `mb-2 p-3 rounded-lg shadow-lg transition-all duration-300 transform translate-x-0 ${
          type === "success"
            ? "bg-green-500 text-white"
            : type === "error"
            ? "bg-red-500 text-white"
            : "bg-blue-500 text-white"
        }`;
        notification.innerHTML = message;
        notificationContainer.appendChild(notification);

        setTimeout(() => {
          notification.classList.add("opacity-0", "translate-x-full");
          setTimeout(() => notification.remove(), 300);
        }, 3000);
      }

      function checkLocalStorage() {
        try {
          const testKey = "test_localStorage";
          localStorage.setItem(testKey, "test");
          const testResult = localStorage.getItem(testKey);
          localStorage.removeItem(testKey);
          return testResult === "test";
        } catch (e) {
          console.warn("localStorage không khả dụng:", e);
          return false;
        }
      }

      function simpleImageHash(base64Image) {
        if (!base64Image) return null;
        let hash = "";
        const sampleSize = 100;
        const len = base64Image.length;
        if (len < sampleSize) return base64Image;

        for (let i = 0; i < sampleSize; i++) {
          const pos = Math.floor(i * (len / sampleSize));
          hash += base64Image.charAt(pos);
        }
        return hash;
      }

      function isSimilarToLastImage(base64Image) {
        if (!base64Image || !lastCapturedHash) return false;
        const currentHash = simpleImageHash(base64Image);
        return currentHash === lastCapturedHash;
      }

      // IndexedDB Functions
      function initIndexedDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);

          request.onupgradeneeded = function (event) {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
              db.createObjectStore(STORE_NAME, { keyPath: "timestamp" });
              console.log("Đã tạo object store mới");
            }
          };

          request.onsuccess = function (event) {
            db = event.target.result;
            console.log("Đã kết nối thành công đến IndexedDB");
            resolve(db);
          };

          request.onerror = function (event) {
            console.error("Lỗi khi mở IndexedDB:", event.target.error);
            reject(event.target.error);
          };
        });
      }

      function loadHistoryFromDB() {
        if (!db) {
          console.error("IndexedDB chưa được khởi tạo khi cố gắng tải lịch sử");
          return Promise.reject(new Error("IndexedDB chưa được khởi tạo"));
        }

        return new Promise((resolve, reject) => {
          try {
            const transaction = db.transaction([STORE_NAME], "readonly");
            const store = transaction.objectStore(STORE_NAME);
            const request = store.getAll();

            request.onsuccess = function (event) {
              const items = event.target.result;
              console.log(`Đã tải ${items.length} mục lịch sử từ IndexedDB`);
              detectionHistory = items.sort(
                (a, b) => b.timestamp - a.timestamp
              );
              resolve(items);
            };

            request.onerror = function (event) {
              console.error(
                "Lỗi khi tải lịch sử từ IndexedDB:",
                event.target.error
              );
              reject(event.target.error);
            };
          } catch (error) {
            console.error("Lỗi khi tải lịch sử từ IndexedDB:", error);
            reject(error);
          }
        });
      }

      function saveHistoryToDB(historyItem) {
        return new Promise((resolve, reject) => {
          if (!db) {
            console.error("IndexedDB chưa được khởi tạo");
            return reject(new Error("IndexedDB chưa được khởi tạo"));
          }

          try {
            const transaction = db.transaction([STORE_NAME], "readwrite");
            const store = transaction.objectStore(STORE_NAME);
            const request = store.put(historyItem);

            request.onsuccess = function (event) {
              console.log(
                "Đã lưu thành công mục lịch sử vào IndexedDB:",
                historyItem.timestamp
              );
              resolve(event.target.result);
            };

            request.onerror = function (event) {
              console.error(
                "Lỗi khi lưu mục lịch sử vào IndexedDB:",
                event.target.error
              );
              reject(event.target.error);
            };
          } catch (error) {
            console.error("Lỗi khi lưu mục lịch sử vào IndexedDB:", error);
            reject(error);
          }
        });
      }

      function deleteHistoryItemFromDB(timestamp) {
        return new Promise((resolve, reject) => {
          if (!db) {
            console.error("IndexedDB chưa được khởi tạo");
            return reject(new Error("IndexedDB chưa được khởi tạo"));
          }

          try {
            const transaction = db.transaction([STORE_NAME], "readwrite");
            const store = transaction.objectStore(STORE_NAME);
            const request = store.delete(timestamp);

            request.onsuccess = function () {
              console.log("Đã xóa mục lịch sử có timestamp:", timestamp);
              resolve();
            };

            request.onerror = function (event) {
              console.error("Lỗi khi xóa mục lịch sử:", event.target.error);
              reject(event.target.error);
            };
          } catch (error) {
            console.error("Lỗi khi xóa mục lịch sử:", error);
            reject(error);
          }
        });
      }

      function clearAllHistory() {
        return new Promise((resolve, reject) => {
          if (!db) {
            console.error("IndexedDB chưa được khởi tạo");
            return reject(new Error("IndexedDB chưa được khởi tạo"));
          }

          try {
            const transaction = db.transaction([STORE_NAME], "readwrite");
            const store = transaction.objectStore(STORE_NAME);
            const request = store.clear();

            request.onsuccess = function () {
              console.log("Đã xóa tất cả lịch sử từ IndexedDB");
              if (checkLocalStorage()) {
                try {
                  localStorage.removeItem("faceDetectionHistory");
                  console.log("Đã xóa lịch sử từ localStorage");
                } catch (e) {
                  console.warn("Không thể xóa localStorage:", e);
                }
              }
              resolve();
            };

            request.onerror = function (event) {
              console.error("Lỗi khi xóa tất cả lịch sử:", event.target.error);
              reject(event.target.error);
            };
          } catch (error) {
            console.error("Lỗi khi xóa tất cả lịch sử:", error);
            reject(error);
          }
        });
      }

      // History UI Functions
      function setupHistoryItemListeners() {
        const historyItems = document.querySelectorAll(".history-item");
        historyItems.forEach((item) => {
          const timestamp = item.getAttribute("data-timestamp");

          item.addEventListener("click", function (event) {
            if (!event.target.closest(".delete-btn")) {
              const historyItem = detectionHistory.find(
                (h) => h.timestamp == timestamp
              );
              if (historyItem) {
                displayHistoryDetail(historyItem);
              }
            }
          });

          const deleteBtn = item.querySelector(".delete-btn");
          if (deleteBtn) {
            deleteBtn.addEventListener("click", function (event) {
              event.stopPropagation();
              if (confirm("Bạn có chắc chắn muốn xóa mục này?")) {
                deleteHistoryItemFromDB(parseInt(timestamp))
                  .then(() => {
                    detectionHistory = detectionHistory.filter(
                      (h) => h.timestamp != timestamp
                    );
                    updateHistoryGrid();
                    showNotification("Đã xóa mục lịch sử", "success");
                  })
                  .catch((error) => {
                    console.error("Lỗi khi xóa mục lịch sử:", error);
                    showNotification("Có lỗi khi xóa mục lịch sử", "error");
                  });
              }
            });
          }
        });
      }

      function updateHistoryGrid() {
        const historyGrid = document.getElementById("historyGrid");
        const emptyHistoryMessage = document.getElementById(
          "emptyHistoryMessage"
        );

        if (!historyGrid) {
          console.warn(
            "Không tìm thấy phần tử historyGrid, đang tạo mới phần tử"
          );
          const historyContainer = document.getElementById("historyContainer");
          if (!historyContainer) {
            console.error(
              "Không tìm thấy historyContainer để thêm historyGrid"
            );
            return;
          }
          const newHistoryGrid = document.createElement("div");
          newHistoryGrid.id = "historyGrid";
          newHistoryGrid.className =
            "grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-4";
          historyContainer.appendChild(newHistoryGrid);
          return updateHistoryGrid();
        }

        if (!emptyHistoryMessage) {
          console.warn(
            "Không tìm thấy phần tử emptyHistoryMessage, đang tạo mới phần tử"
          );
          const historyContainer = document.getElementById("historyContainer");
          if (historyContainer) {
            const newEmptyMessage = document.createElement("div");
            newEmptyMessage.id = "emptyHistoryMessage";
            newEmptyMessage.className = "text-center py-8 text-gray-500";
            newEmptyMessage.innerHTML =
              "Chưa có lịch sử nhận diện nào. Hãy chụp ảnh để bắt đầu!";
            historyContainer.insertBefore(newEmptyMessage, historyGrid);
          }
        }

        historyGrid.innerHTML = "";

        if (!detectionHistory || detectionHistory.length === 0) {
          if (emptyHistoryMessage) {
            emptyHistoryMessage.classList.remove("hidden");
          }
          return;
        }

        if (emptyHistoryMessage) {
          emptyHistoryMessage.classList.add("hidden");
        }

        detectionHistory.forEach((item) => {
          const historyItem = document.createElement("div");
          historyItem.className =
            "history-item relative bg-white rounded-lg overflow-hidden shadow-sm border border-gray-200 hover:shadow-md transition-shadow duration-200";
          historyItem.setAttribute("data-timestamp", item.timestamp);

          const date = new Date(item.timestamp);
          const formattedDate = `${date.toLocaleDateString(
            "vi-VN"
          )} ${date.toLocaleTimeString("vi-VN")}`;

          historyItem.innerHTML = `
        <div class="absolute top-2 right-2">
          <button class="delete-btn text-gray-400 hover:text-red-500 focus:outline-none" title="Xóa">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
            </svg>
          </button>
        </div>
        <div class="w-full h-32 bg-gray-100">
          ${
            item.image
              ? `<img src="data:image/jpeg;base64,${item.image}" alt="History thumbnail" class="w-full h-full object-cover">`
              : `<div class="w-full h-full flex items-center justify-center">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                  </svg>
                </div>`
          }
        </div>
        <div class="p-3">
          <div class="text-xs text-gray-500 mb-1">${formattedDate}</div>
          <div class="font-medium">${
            item.expressions
              ? `${item.expressions.length} khuôn mặt`
              : "Không có khuôn mặt"
          }</div>
        </div>
      `;

          historyGrid.appendChild(historyItem);
        });

        setupHistoryItemListeners();
      }

      function addToHistory(result, imageBase64) {
        try {
          console.log("Thêm vào lịch sử với dữ liệu:", result);
          if (!result) {
            console.error("Không có dữ liệu kết quả để lưu vào lịch sử");
            return;
          }

          const expressionsData = result.detections || result.expressions || [];
          const historyItem = {
            timestamp: Date.now(),
            expressions: expressionsData,
            image: imageBase64,
          };

          detectionHistory.unshift(historyItem);

          saveHistoryToDB(historyItem)
            .then(() => {
              console.log("Đã lưu mục lịch sử vào IndexedDB");
              updateHistoryGrid();
            })
            .catch((error) => {
              console.error("Lỗi khi thêm vào IndexedDB:", error);
              updateHistoryGrid();
            });
        } catch (error) {
          console.error("Lỗi khi thêm vào lịch sử:", error);
        }
      }

      // Result Display Functions
      function debugHistoryData(data) {
        console.group("Debug dữ liệu lịch sử");
        console.log("Loại dữ liệu:", typeof data);
        console.log("Có phải là null?", data === null);

        if (data) {
          console.log("Các thuộc tính:", Object.keys(data));
          if (data.expressions) {
            console.log("Số lượng biểu cảm:", data.expressions.length);
            if (data.expressions.length > 0) {
              console.log("Biểu cảm đầu tiên:", data.expressions[0]);
            }
          } else {
            console.log("Không có thuộc tính expressions");
          }
          if (data.detections) {
            console.log("Số lượng detections:", data.detections.length);
            if (data.detections.length > 0) {
              console.log("Detection đầu tiên:", data.detections[0]);
            }
          } else {
            console.log("Không có thuộc tính detections");
          }
          if (data.image) {
            console.log("Độ dài ảnh:", data.image.length);
          } else {
            console.log("Không có thuộc tính image");
          }
        }
        console.groupEnd();
      }

      function cropFaceImage(base64Image, boundingBox, faceIndex) {
        return new Promise((resolve, reject) => {
          if (!base64Image) {
            console.warn(`Face #${faceIndex + 1}: Không có ảnh gốc để cắt`);
            resolve(null);
            return;
          }

          const img = new Image();
          img.onload = function () {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            let x, y, width, height;
            if (
              boundingBox &&
              typeof boundingBox.x === "number" &&
              typeof boundingBox.y === "number" &&
              typeof boundingBox.width === "number" &&
              typeof boundingBox.height === "number" &&
              boundingBox.width > 10 &&
              boundingBox.height > 10
            ) {
              x = Math.round(boundingBox.x);
              y = Math.round(boundingBox.y);
              width = Math.round(boundingBox.width);
              height = Math.round(boundingBox.height);
              console.log(
                `Face #${
                  faceIndex + 1
                }: Sử dụng bounding box (${x},${y},${width},${height})`
              );
            } else {
              width = Math.round(img.width * 0.6);
              height = Math.round(img.height * 0.6);
              x = Math.round((img.width - width) / 2);
              y = Math.round((img.height - height) / 2);
              console.log(
                `Face #${
                  faceIndex + 1
                }: Không tìm thấy bounding box hợp lệ, tạo vùng cắt tại trung tâm ảnh (${x},${y},${width},${height})`
              );
            }

            x = Math.max(0, x);
            y = Math.max(0, y);
            width = Math.min(width, img.width - x);
            height = Math.min(height, img.height - y);

            if (width < 10 || height < 10) {
              console.warn(
                `Face #${
                  faceIndex + 1
                }: Vùng cắt quá nhỏ (${width}x${height}), sử dụng ảnh gốc`
              );
              resolve(base64Image);
              return;
            }

            canvas.width = width;
            canvas.height = height;

            try {
              ctx.drawImage(img, x, y, width, height, 0, 0, width, height);
              const croppedImage = canvas.toDataURL("image/jpeg").split(",")[1];
              console.log(
                `Face #${
                  faceIndex + 1
                }: Đã cắt ảnh thành công, độ dài base64: ${croppedImage.length}`
              );
              resolve(croppedImage);
            } catch (e) {
              console.error(`Face #${faceIndex + 1}: Lỗi khi cắt ảnh:`, e);
              resolve(base64Image);
            }
          };

          img.onerror = function () {
            console.error(
              `Face #${faceIndex + 1}: Không thể tải ảnh gốc để cắt`
            );
            resolve(null);
          };

          img.src = `data:image/jpeg;base64,${base64Image}`;
        });
      }

      function createFaceCard(face, faceIndex, croppedImage) {
        const card = document.createElement("div");
        card.className =
          "bg-white rounded-lg overflow-hidden shadow-sm border border-gray-200";

        let imageHTML = "";
        if (croppedImage) {
          imageHTML = `
        <div class="w-full h-48 overflow-hidden bg-gray-50 p-2">
          <div class="w-full h-full flex items-center justify-center">
            <img
              src="data:image/jpeg;base64,${croppedImage}"
              alt="Face ${faceIndex + 1}"
              class="max-w-full max-h-full object-contain"
              onerror="this.onerror=null; this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI2NjYyI+PHBhdGggZD0iTTEwIDIwdi02aDR2Nmg1di04aDNMMTIgMyAyIDEyaDN2OHoiLz48L3N2Zz4=';"
            >
          </div>
        </div>
      `;
        } else {
          imageHTML = `
        <div class="w-full h-48 flex items-center justify-center bg-gray-100">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
          </svg>
        </div>
      `;
        }

        let accuracyHTML = "";
        if (face.confidence !== undefined) {
          const accuracyPercentage = Math.round(face.confidence * 100);
          const accuracyColorClass =
            accuracyPercentage >= 90
              ? "text-green-600"
              : accuracyPercentage >= 70
              ? "text-yellow-600"
              : "text-red-600";
          accuracyHTML = `
        <div class="flex items-center justify-between mb-2 text-sm">
          <span>Độ chính xác:</span>
          <span class="font-medium ${accuracyColorClass}">${accuracyPercentage}%</span>
        </div>
      `;
        }

        const contentHTML = `
      <div class="p-4">
        <div class="flex justify-between items-start">
          <h3 class="font-bold text-lg mb-2">${
            face.expression || "Không xác định"
          }</h3>
          <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full">#${
            faceIndex + 1
          }</span>
        </div>
        ${accuracyHTML}
        <div class="space-y-2">
          ${Object.entries(face.probabilities || {})
            .sort((a, b) => b[1] - a[1])
            .map(
              ([emotion, prob]) => `
              <div>
                <div class="flex justify-between text-sm mb-1">
                  <span>${emotion}</span>
                  <span>${Math.round(prob * 100)}%</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2">
                  <div class="bg-blue-600 h-2 rounded-full" style="width: ${Math.round(
                    prob * 100
                  )}%"></div>
                </div>
              </div>
            `
            )
            .join("")}
        </div>
      </div>
    `;

        card.innerHTML = imageHTML + contentHTML;
        return card;
      }

      function displayResult(result, skipHistory = false) {
        console.log("Hiển thị kết quả, skipHistory =", skipHistory);
        debugHistoryData(result);

        const resultCopy = JSON.parse(JSON.stringify(result));
        if (!resultCopy.expressions && resultCopy.detections) {
          resultCopy.expressions = resultCopy.detections;
        }

        const hasFaces =
          resultCopy.expressions && resultCopy.expressions.length > 0;
        if (hasFaces && !skipHistory) {
          console.log(
            "Phát hiện",
            resultCopy.expressions.length,
            "khuôn mặt, đang lưu vào lịch sử"
          );
          addToHistory(resultCopy, resultCopy.image);
        } else if (!hasFaces) {
          console.log("Không phát hiện khuôn mặt nào, bỏ qua việc lưu lịch sử");
          showNotification("Không phát hiện khuôn mặt nào trong ảnh", "error");
        }

        const resultContainer = document.getElementById("resultContainer");
        resultContainer.classList.remove("hidden");

        if (!resultCopy.expressions || resultCopy.expressions.length === 0) {
          resultContainer.innerHTML = `
        <h2 class="text-xl font-bold mb-4">Kết quả phân tích</h2>
        <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4">
          <p class="text-yellow-700">Không phát hiện khuôn mặt nào trong hình ảnh.</p>
        </div>
      `;
          return;
        }

        let resultHTML = `
      <h2 class="text-xl font-bold mb-4">Kết quả phân tích</h2>
      <p class="mb-4">Đã phát hiện ${resultCopy.expressions.length} khuôn mặt trong hình ảnh.</p>
      <div class="grid grid-cols-1 lg:grid-cols-12 gap-6 mb-6">
        <div class="lg:col-span-5">
          <div class="bg-white rounded-lg overflow-hidden shadow-sm border border-gray-200">
            <h3 class="bg-gray-50 px-4 py-2 font-semibold">Hình ảnh gốc</h3>
            <div class="p-4 flex justify-center items-center">
              <div id="originalImageContainer" class="relative max-w-full">
              </div>
            </div>
          </div>
        </div>
        <div class="lg:col-span-7">
          <div class="bg-white rounded-lg overflow-hidden shadow-sm border border-gray-200">
            <h3 class="bg-gray-50 px-4 py-2 font-semibold">Danh sách khuôn mặt</h3>
            <div id="facesContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4 p-4">
            </div>
          </div>
        </div>
      </div>
    `;

        resultContainer.innerHTML = resultHTML;

        const originalImageContainer = document.getElementById(
          "originalImageContainer"
        );
        if (originalImageContainer && resultCopy.image) {
          const img = document.createElement("img");
          img.src = `data:image/jpeg;base64,${resultCopy.image}`;
          img.className = "max-w-full";
          img.alt = "Original image";
          img.onerror = function () {
            console.error("Không thể tải ảnh gốc");
            this.onerror = null;
            this.src =
              "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI2NjYyI+PHBhdGggZD0iTTEwIDIwdi02aDR2Nmg1di04aDNMMTIgMyAyIDEyaDN2OHoiLz48L3N2Zz4='";
          };
          originalImageContainer.appendChild(img);

          if (resultCopy.expressions) {
            resultCopy.expressions.forEach((face, index) => {
              if (face.bounding_box) {
                const { x, y, width, height } = face.bounding_box;
                img.onload = function () {
                  const imgWidth = this.width;
                  const imgHeight = this.height;
                  const box = document.createElement("div");
                  box.className = "absolute border-2 border-blue-500";
                  box.style.left = `${(x / 100) * imgWidth}px`;
                  box.style.top = `${(y / 100) * imgHeight}px`;
                  box.style.width = `${(width / 100) * imgWidth}px`;
                  box.style.height = `${(height / 100) * imgHeight}px`;
                  const label = document.createElement("div");
                  label.className =
                    "absolute top-0 left-0 bg-blue-500 text-white text-xs px-1 py-0.5";
                  label.textContent = `#${index + 1}`;
                  box.appendChild(label);
                  originalImageContainer.appendChild(box);
                };
              }
            });
          }
        }

        const facesContainer = document.getElementById("facesContainer");
        if (facesContainer && resultCopy.expressions) {
          console.log(
            "Đang hiển thị",
            resultCopy.expressions.length,
            "khuôn mặt"
          );
          Promise.all(
            resultCopy.expressions.map(async (face, index) => {
              try {
                let croppedImage = null;
                if (resultCopy.image && face.bounding_box) {
                  croppedImage = await cropFaceImage(
                    resultCopy.image,
                    face.bounding_box,
                    index
                  );
                }
                return createFaceCard(face, index, croppedImage);
              } catch (error) {
                console.error(`Lỗi xử lý khuôn mặt #${index + 1}:`, error);
                const errorCard = document.createElement("div");
                errorCard.className =
                  "bg-white rounded-lg overflow-hidden shadow-sm border border-gray-200 p-4";
                errorCard.innerHTML = `
              <div class="text-center text-red-500">
                <p>Lỗi hiển thị khuôn mặt #${index + 1}</p>
              </div>
            `;
                return errorCard;
              }
            })
          )
            .then((faceCards) => {
              faceCards.forEach((card) => facesContainer.appendChild(card));
            })
            .catch((error) => {
              console.error("Lỗi khi hiển thị các khuôn mặt:", error);
              facesContainer.innerHTML = `
            <div class="col-span-full bg-red-50 border-l-4 border-red-400 p-4">
              <p class="text-red-700">Đã xảy ra lỗi khi hiển thị khuôn mặt. Vui lòng thử lại.</p>
            </div>
          `;
            });
        }
      }

      async function displayHistoryDetail(historyItem) {
        console.log("Hiển thị chi tiết lịch sử:", historyItem);

        let modalContainer = document.getElementById("detailModal");
        if (!modalContainer) {
          modalContainer = document.createElement("div");
          modalContainer.id = "detailModal";
          modalContainer.className =
            "fixed inset-0 z-50 overflow-auto bg-black bg-opacity-50 flex justify-center items-center";
          modalContainer.style.display = "none";
          document.body.appendChild(modalContainer);
          modalContainer.addEventListener("click", function (e) {
            if (e.target === this) {
              this.style.display = "none";
            }
          });
        }

        let modalContent = document.createElement("div");
        modalContent.className =
          "bg-white rounded-lg max-w-4xl w-full max-h-90vh overflow-auto";
        modalContainer.innerHTML = "";
        modalContainer.appendChild(modalContent);
        modalContainer.style.display = "flex";

        modalContent.innerHTML = `
      <div class="p-6">
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-xl font-bold">Chi tiết nhận diện</h2>
          <button class="text-gray-500 hover:text-gray-700 focus:outline-none" id="closeDetailModal">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        <div class="text-center py-10">
          <div class="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500"></div>
          <p class="mt-2 text-gray-600">Đang tải dữ liệu...</p>
        </div>
      </div>
    `;

        document
          .getElementById("closeDetailModal")
          .addEventListener("click", function () {
            modalContainer.style.display = "none";
          });

        try {
          const date = new Date(historyItem.timestamp);
          const formattedDate = `${date.toLocaleDateString(
            "vi-VN"
          )} ${date.toLocaleTimeString("vi-VN")}`;

          const facesPromises = [];
          if (
            historyItem.expressions &&
            historyItem.expressions.length > 0 &&
            historyItem.image
          ) {
            historyItem.expressions.forEach((face, index) => {
              if (face.bounding_box) {
                facesPromises.push(
                  cropFaceImage(historyItem.image, face.bounding_box, index)
                    .then((croppedImage) => ({
                      index: index,
                      face: face,
                      croppedImage: croppedImage,
                    }))
                    .catch((error) => {
                      console.error(
                        `Lỗi khi cắt ảnh khuôn mặt #${index + 1}:`,
                        error
                      );
                      return {
                        index: index,
                        face: face,
                        croppedImage: null,
                        error: error.message,
                      };
                    })
                );
              } else {
                facesPromises.push(
                  Promise.resolve({
                    index: index,
                    face: face,
                    croppedImage: null,
                  })
                );
              }
            });
          }

          const facesResults = await Promise.all(facesPromises);

          let modalBody = `
        <div class="p-6">
          <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold">Chi tiết nhận diện</h2>
            <button class="text-gray-500 hover:text-gray-700 focus:outline-none" id="closeDetailModal">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          <div class="text-sm text-gray-500 mb-4">${formattedDate}</div>
          <div class="grid grid-cols-1 lg:grid-cols-12 gap-6 mb-6">
            <div class="lg:col-span-5">
              <div class="bg-white rounded-lg overflow-hidden shadow-sm border border-gray-200">
                <h3 class="bg-gray-50 px-4 py-2 font-semibold">Hình ảnh gốc</h3>
                <div class="p-4 flex justify-center items-center">
                  <div id="originalImageContainer" class="relative max-w-full">
                    ${
                      historyItem.image
                        ? `<img src="data:image/jpeg;base64,${historyItem.image}" alt="Original image" class="max-w-full">`
                        : `<div class="w-full h-32 bg-gray-100 flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                            </svg>
                          </div>`
                    }
                  </div>
                </div>
              </div>
            </div>
            <div class="lg:col-span-7">
              <div class="bg-white rounded-lg overflow-hidden shadow-sm border border-gray-200">
                <h3 class="bg-gray-50 px-4 py-2 font-semibold">Danh sách khuôn mặt</h3>
                <div id="modalFacesContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4 p-4">
                </div>
              </div>
            </div>
          </div>
        </div>
      `;

          modalContent.innerHTML = modalBody;

          const originalImgContainer = modalContent.querySelector(
            "#originalImageContainer"
          );
          const originalImg = originalImgContainer?.querySelector("img");
          if (originalImg && historyItem.expressions) {
            originalImg.onload = function () {
              const imgWidth = this.width;
              const imgHeight = this.height;
              historyItem.expressions.forEach((face, idx) => {
                if (face.bounding_box) {
                  const { x, y, width, height } = face.bounding_box;
                  const box = document.createElement("div");
                  box.className = "absolute border-2 border-blue-500";
                  box.style.left = `${(x / 100) * imgWidth}px`;
                  box.style.top = `${(y / 100) * imgHeight}px`;
                  box.style.width = `${(width / 100) * imgWidth}px`;
                  box.style.height = `${(height / 100) * imgHeight}px`;
                  const label = document.createElement("div");
                  label.className =
                    "absolute top-0 left-0 bg-blue-500 text-white text-xs px-1 py-0.5";
                  label.textContent = `#${idx + 1}`;
                  box.appendChild(label);
                  originalImgContainer.appendChild(box);
                }
              });
            };
          }

          const modalFacesContainer = modalContent.querySelector(
            "#modalFacesContainer"
          );
          if (modalFacesContainer && facesResults.length > 0) {
            facesResults.forEach((result) => {
              const faceCard = createFaceCard(
                result.face,
                result.index,
                result.croppedImage
              );
              modalFacesContainer.appendChild(faceCard);
            });
          } else if (modalFacesContainer) {
            modalFacesContainer.innerHTML = `
          <div class="col-span-full text-center py-4 text-gray-500">
            Không có dữ liệu khuôn mặt
          </div>
        `;
          }

          document
            .getElementById("closeDetailModal")
            .addEventListener("click", function () {
              modalContainer.style.display = "none";
            });
        } catch (error) {
          console.error("Lỗi khi hiển thị chi tiết lịch sử:", error);
          modalContent.innerHTML = `
        <div class="p-6">
          <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold">Chi tiết nhận diện</h2>
            <button class="text-gray-500 hover:text-gray-700 focus:outline-none" id="closeDetailModal">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          <div class="bg-red-50 border-l-4 border-red-400 p-4">
            <p class="text-red-700">Đã xảy ra lỗi khi hiển thị chi tiết: ${error.message}</p>
          </div>
        </div>
      `;
          document
            .getElementById("closeDetailModal")
            .addEventListener("click", function () {
              modalContainer.style.display = "none";
            });
        }
      }

      // API Request Handler
      async function analyzeImage(imageBase64, source) {
        try {
          const blob = await (
            await fetch(`data:image/jpeg;base64,${imageBase64}`)
          ).blob();
          const formData = new FormData();
          formData.append("image", blob, `${source}-image.jpg`);

          console.log(
            `Sending request to /face-expression/predict for ${source}...`
          );
          const response = await fetch(
            "http://localhost:9009/face-expression/predict",
            {
              method: "POST",
              body: formData,
            }
          );

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Lỗi từ server: ${response.status} - ${errorText}`);
          }

          const result = await response.json();
          result.image = imageBase64;
          console.log(
            `Assigned ${source} image to result, base64 length:`,
            result.image.length
          );
          return result;
        } catch (error) {
          throw error;
        }
      }

      // Event Listeners
      // Tab Switching
      document.querySelectorAll(".tab").forEach((tab) => {
        tab.addEventListener("click", () => {
          const tabName = tab.getAttribute("data-tab");
          document
            .querySelectorAll(".tab")
            .forEach((t) =>
              t.classList.remove("active", "bg-white", "font-bold")
            );
          document
            .querySelectorAll(".tab")
            .forEach((t) => t.classList.add("bg-gray-200"));
          document
            .querySelectorAll(".tab-content")
            .forEach((c) => c.classList.add("hidden"));

          tab.classList.add("active", "bg-white", "font-bold");
          tab.classList.remove("bg-gray-200");
          document.getElementById(`${tabName}-tab`).classList.remove("hidden");
        });
      });

      // File Upload
      document
        .getElementById("submitBtn")
        .addEventListener("click", async () => {
          const fileInput = document.getElementById("imageUpload");
          const file = fileInput.files[0];

          if (!file) {
            showError("Vui lòng chọn một hình ảnh", "uploadError");
            return;
          }

          const loading = document.getElementById("uploadLoading");
          const resultContainer = document.getElementById("resultContainer");
          const errorMessage = document.getElementById("uploadError");

          resultContainer.classList.add("hidden");
          errorMessage.classList.add("hidden");
          loading.classList.remove("hidden");

          const fileReader = new FileReader();
          fileReader.onload = async function (event) {
            const base64Image = event.target.result.split(",")[1];
            currentCapturedImage = base64Image;
            console.log(
              "Đã đọc file upload thành base64, độ dài:",
              base64Image.length
            );

            try {
              const result = await analyzeImage(base64Image, "upload");
              displayResult(result);
            } catch (error) {
              console.error("Error during upload analysis:", error);
              showError(
                `Không thể phân tích ảnh: ${error.message}`,
                "uploadError"
              );
            } finally {
              loading.classList.add("hidden");
            }
          };

          fileReader.onerror = function () {
            showError("Không thể đọc file hình ảnh", "uploadError");
            loading.classList.add("hidden");
          };

          fileReader.readAsDataURL(file);
        });

      // Webcam Handling
      const video = document.getElementById("video");

      document
        .getElementById("startWebcam")
        .addEventListener("click", async () => {
          try {
            document.getElementById("webcamError").classList.add("hidden");

            if (window.currentStream) {
              window.currentStream.getTracks().forEach((track) => track.stop());
            }

            const constraints = { video: true };
            console.log("Đang mở camera mặc định");
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            window.currentStream = stream;

            video.srcObject = stream;
            video.classList.remove("hidden");
            document.getElementById("startWebcam").classList.add("hidden");
            document.getElementById("stopWebcam").classList.remove("hidden");
            document.getElementById("captureBtn").classList.remove("hidden");
          } catch (error) {
            showError(
              `Không thể truy cập webcam: ${error.message}`,
              "webcamError"
            );
          }
        });

      document.getElementById("stopWebcam").addEventListener("click", () => {
        if (video.srcObject) {
          const tracks = video.srcObject.getTracks();
          tracks.forEach((track) => track.stop());
          video.srcObject = null;
        }

        video.classList.add("hidden");
        document.getElementById("stopWebcam").classList.add("hidden");
        document.getElementById("captureBtn").classList.add("hidden");
        document.getElementById("startWebcam").classList.remove("hidden");

        const note = document.getElementById("faceNotification");
        if (note) note.remove();
      });

      document
        .getElementById("captureBtn")
        .addEventListener("click", async () => {
          const loading = document.getElementById("webcamLoading");
          const resultContainer = document.getElementById("resultContainer");
          const errorMessage = document.getElementById("webcamError");

          resultContainer.classList.add("hidden");
          errorMessage.classList.add("hidden");
          loading.classList.remove("hidden");

          const captureCanvas = document.getElementById("captureCanvas");
          captureCanvas.width = video.videoWidth;
          captureCanvas.height = video.videoHeight;

          const ctx = captureCanvas.getContext("2d");
          ctx.drawImage(video, 0, 0, captureCanvas.width, captureCanvas.height);

          const imageBase64 = captureCanvas
            .toDataURL("image/jpeg")
            .split(",")[1];
          currentCapturedImage = imageBase64;

          try {
            const result = await analyzeImage(imageBase64, "webcam");
            displayResult(result);
          } catch (error) {
            console.error("Error during webcam analysis:", error);
            showError(
              `Không thể phân tích ảnh: ${error.message}`,
              "webcamError"
            );
          } finally {
            loading.classList.add("hidden");
          }
        });

      // Paste Image Handling
      document.addEventListener("paste", (event) => {
        const pasteTab = document.querySelector('.tab[data-tab="paste"]');
        if (pasteTab) {
          pasteTab.click();
        }

        const items = (event.clipboardData || event.originalEvent.clipboardData)
          .items;
        let imageFound = false;

        for (const item of items) {
          if (item.type.indexOf("image") !== -1) {
            const blob = item.getAsFile();
            const reader = new FileReader();

            reader.onload = (e) => {
              pastedImageBase64 = e.target.result.split(",")[1];
              console.log(
                "Pasted image base64 length:",
                pastedImageBase64.length
              );

              const preview = document.getElementById("pastedImagePreview");
              preview.src = e.target.result;
              preview.classList.remove("hidden");

              document
                .getElementById("pasteSubmitBtn")
                .classList.remove("hidden");
              document.getElementById("pasteError").classList.add("hidden");
            };

            reader.onerror = () => {
              showError("Không thể đọc ảnh từ clipboard", "pasteError");
            };

            reader.readAsDataURL(blob);
            imageFound = true;
            break;
          }
        }

        if (!imageFound) {
          showError("Không tìm thấy ảnh trong clipboard", "pasteError");
        }
      });

      document
        .getElementById("pasteSubmitBtn")
        .addEventListener("click", async () => {
          if (!pastedImageBase64) {
            showError("Vui lòng dán một ảnh trước", "pasteError");
            return;
          }

          const loading = document.getElementById("pasteLoading");
          const resultContainer = document.getElementById("resultContainer");
          const errorMessage = document.getElementById("pasteError");

          resultContainer.classList.add("hidden");
          errorMessage.classList.add("hidden");
          loading.classList.remove("hidden");

          try {
            const result = await analyzeImage(pastedImageBase64, "pasted");
            displayResult(result);

            // Reset the paste area after analysis
            pastedImageBase64 = null;
            document
              .getElementById("pastedImagePreview")
              .classList.add("hidden");
            document.getElementById("pasteSubmitBtn").classList.add("hidden");
          } catch (error) {
            console.error("Error during paste analysis:", error);
            showError(
              `Không thể phân tích ảnh: ${error.message}`,
              "pasteError"
            );
          } finally {
            loading.classList.add("hidden");
          }
        });

      // Clear History Button
      function addDeleteHistoryButton() {
        const clearHistoryBtn = document.getElementById("clearHistoryBtn");
        if (clearHistoryBtn) {
          clearHistoryBtn.addEventListener("click", function () {
            if (confirm("Bạn có chắc chắn muốn xóa tất cả lịch sử?")) {
              clearAllHistory()
                .then(() => {
                  detectionHistory = [];
                  updateHistoryGrid();
                  showNotification("Đã xóa tất cả lịch sử", "success");
                })
                .catch((error) => {
                  console.error("Lỗi khi xóa lịch sử:", error);
                  showNotification("Có lỗi khi xóa lịch sử", "error");
                });
            }
          });
        } else {
          console.warn("Không tìm thấy phần tử clearHistoryBtn");
        }
      }

      // Initialize on Page Load
      document.addEventListener("DOMContentLoaded", function () {
        initIndexedDB()
          .then(() => {
            console.log("IndexedDB đã sẵn sàng");
            return loadHistoryFromDB();
          })
          .then(() => {
            if (
              checkLocalStorage() &&
              (!detectionHistory || detectionHistory.length === 0)
            ) {
              try {
                const savedHistory = localStorage.getItem(
                  "faceDetectionHistory"
                );
                if (savedHistory) {
                  detectionHistory = JSON.parse(savedHistory);
                  console.log(
                    "Đã tải lịch sử từ localStorage:",
                    detectionHistory.length,
                    "mục"
                  );
                  Promise.all(
                    detectionHistory.map((item) => saveHistoryToDB(item))
                  ).then(() => {
                    console.log(
                      "Đã đồng bộ lịch sử từ localStorage vào IndexedDB"
                    );
                    updateHistoryGrid();
                  });
                } else {
                  updateHistoryGrid();
                }
              } catch (error) {
                console.error("Lỗi khi tải lịch sử từ localStorage:", error);
                updateHistoryGrid();
              }
            } else {
              updateHistoryGrid();
            }
          })
          .catch((error) => {
            console.error("Lỗi khi khởi tạo hoặc tải từ IndexedDB:", error);
            if (checkLocalStorage()) {
              try {
                const savedHistory = localStorage.getItem(
                  "faceDetectionHistory"
                );
                if (savedHistory) {
                  detectionHistory = JSON.parse(savedHistory);
                  console.log(
                    "Đã tải lịch sử từ localStorage (fallback):",
                    detectionHistory.length,
                    "mục"
                  );
                }
              } catch (error) {
                console.error("Lỗi khi tải lịch sử từ localStorage:", error);
              }
            }
            updateHistoryGrid();
          });

        addDeleteHistoryButton();
      });
    </script>
  </body>
</html>
